 CSS ( Cascading StyleSheet ) 강좌정리

 1. CSS 역할 및 버전
  
   1)역할
     html에 시각적 표현을 지정해서 스타일 관리.

   2)버전
    
     CSS1: 1996 년
     CSS2: 1998 년
     CSS3: 현재까지 계속 개발중. ( 표준화 버전 )

 2. html에 CSS 적용하는 방법

   1)인라인 스타일 ( inline style)
     - html의 시작태그에서 style 속성을 이용해서 스타일 적용
      예> <p style="color:red">Hello</p>

   2)내부 스타일 ( internal style)
     - <style> 태그에서 CSS 설정하는 방법
     예>
         <head>
	   <style>
	      
	      선택자{
                css속성명(property): css속성값(value);
	      }
     	   </style>
         </head>

            <div>
	      <p id="xx" class="main">Hello</p>

   3)외부 스타일 ( external style)
     - html 파일 외부에 *.css 형식의 파일작성해서 스타일 설정하는 방법.
       필요한 html에서 참조해서 사용 ( <link rel="stylesheet"  href="*.css" > )
     - 같은 *.css 파일을 사용하는 여러 html 페이지는 맨 처음 요청한 페이지에서 다운로드 받아서 
       웹 브라우저 캐시 메모리에 저장된 *.css 파일을 재사용해서 참조한다.

       예>
           // test.css
	      선택자{
                css속성명(property): css속성값(value);
	      }
  
           // html
            <link rel="stylesheet"  href="test.css" >


    4) 우선순위
     
        인라인 스타일 > 내부 스타일 > 외부 스타일


 3.  CSS 선수 내용

   1) 캐스케이딩 ( Cascading )

       html
        |
     head  body
            |
	    div
	    |
	    p

     개념: DOM 트리의 상위에서 정의한 스타일이 하위 요소로 전달되는 개념이다.
          하나의 요소에 여러 스타일이 지정될 수 있다.
	  이러한 규칙은 충돌이 발생될 수 있다.
	  하위에서 재정의도 가능.

   2) 명시도 ( Specificity )
https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity

     개념: 선택자(selector)마다 우선순위가 있음.
         같은 명시도를 가지면 나중에 정의한 선택자가 적용됨.
	 명시도만 고려하면 나중에 설정했다고 해서 덮어쓰는 것이 아니다.

     우선순위(*****)

        인라인 > id > class , 속성명(예> href ) > 태그


     !important
      => 권장안함
      => 기본적인 명시도의 가중치값을 무시하고 가장 최우선 순위를 갖는다.
 
       예>
          a{
            color:blueviolet !important;
          }

      선택자를 결합해서 구체적으로 지정할 수록 명시도가 올라간다.
      이유는 지정된 선택자를 모두 사용하기 때문이다.

 4. CSS 선택자 ( selector )

  1)개념
   
       html
        |
     head        body
              |        |
	    div       div
	     |          |
	    p         div
	               | 
		      span

    DOM 트리에서 특정 태그를 선택하는 방법.

  2) 문법

   가. 전체 선택자
     - * 표현
     - DOM 트리에 있는 모든 태그가 선택됨.

     예>
        <style>
            *{
             color:red;
	    }
	</style>

   나. 태그 선택자
     - 태그명으로 표현
      만약에 여러개 표현할 때는  ,(쉼표) 지정하고 나열.
     - 명시도 ( 0,0,1 )
       예>
        <style>
            div{
             color:red;
	    }
	    div,p{
             color:red;
	    }
	</style>

   다. id 선택자
     - #id값 표현
     - 유일한값 지정.
     - 명시도 ( 1,0,0 )
   예>
        <style>
            #xxx{
             color:red;
	    }
	    div, #xxx{
             color:red;
	    }
	</style>

	<p id="xxx">hello</p>


    라. class 선택자 (**********)
       - .class값 표현
       - 중복값 가능
       - 한번에 여러값을 지정 가능  예> class="값 값1 값2"
       - 명시도 ( 0,1,0 )
       예>
        <style>
            .xxx{
              color:red;
	    }
	    //헷갈릴만한 내용
	    span .xxx {} <== span를 찾고 그 자손으로 class="xxx" 인 요소를 찾음.
	    span.xxx {}  <== and,  span이면서 class="xxx" 인 요소를 찾음.
	    span, .xxx {} <== or,  span 또는 class="xxx" 인 요소를 찾음.
	</style>

	<p class="xxx">hello1</p>
	<p class="yyy zzz">hello2</p>
	<span class="xxx">hello1</span>
	<span >hello1</span>

    마. 계층구조1- 자식
     
      - 부모태그  >  자식태그
         예>
        <style>
            .xxx > p{
              color:red;
	    }
        </style> 

   마. 계층구조2- 자손 (공백)
     
      - 부모태그    자손태그  
      - 자식포함

         예>
        <style>
            .xxx  p{
              color:red;
	    }
        </style> 

   마. 계층구조3- 형제 ( sibling )
     
      - 선택자 +  형제 태그
      - 인접한 바로 뒤 형제만 참조 ( 바로 뒤에 없으면 참조 불가 )

         예>
        <style>
            .xxx + p{
              color:red;
	    }
        </style> 

  마. 계층구조4- 형제들 ( siblings )
     
      - 선택자 ~ 형제 태그
      - 인접한 요소 뒤의 모든 형제 참조

         예>
        <style>
            .xxx ~ p{
              color:red;
	    }
        </style> 


   바. 속성으로 찾기
    
      a. 속성명으로 찾기
       
        - [속성명] 표현,  태그[속성명] <== and 조거

	예> a[href]{

	    }

      b. 속성값으로 찾기 ( 속성값은 정확하게 일치해야 됨 )
       
        - [속성명="속성값"] 표현,  태그[속성명="속성값"] <== and 조거

	예> [class="xxx"]{

	    }

      c. 특정 속성값으로 시작하는 요소 찾기 
       
        - [속성명^="속성값"] 표현,  태그[속성명^="속성값"] <== and 조거

	예> a[href^="https"]{

	    }
      d. 특정 속성값으로 끝나는 요소 찾기 
       
        - [속성명는$="속성값"] 표현,  태그[속성명$="속성값"] <== and 조거

	예> a[href$="com"]{

	    }

      e. 특정값을 포함하는 요소 찾기 
       
        - [속성명는*="속성값"] 표현,  태그[속성명*="속성값"] <== and 조거

	예> a[href*="www"]{

	    }


5.  의사코드 ( pseudo code )
  
   - html의 시멘티 태그처럼 이름안에 기능이 내포되어 있는 선택자 의미.


  1) 의사 클래스  ( pseudo class )
    - :클래스명

     예> :first-child
        :last-child
	:only-child
	:checked
	...

     가. a 태그의 link 관련 의사 클래스 ( 순서 중요 )

        방문전(기본:blue):       a:link { color:red;}
	방문후(기본:purple):     a:visited { color:green;}
	마우스오버:              a:hover { color:yellow;}
	누르고 있을때(기본:red):   a:active { color:blue;}


      나. 자식 선택하는 의사 클래스 ( 지정된 선택자의 부모 기준 (************))

         a.  선택자:first-child 

          예> p:first-child {} <== p 태그를 찾고 찾은 p태그의 첫 번째 자식을 참조 ( X )
	                          p 태그의 부모를 찾고 그 부모의 첫번째 자식인 p태그 참조 (o)

             선택자:first-of-type {} 
	     p:first-of-type {} < == 부모를 찾기전에 선처리로 p만 모두 추출후 
	                            p 태그의 부모를 찾고 그 부모의 첫번째 자식인 p태그 참조 (o)


         b.  선택자:last-child 

          예> p:last-child {} <== p 태그를 찾고 찾은 p태그의 마지막 자식을 참조 ( X )
	                          p 태그의 부모를 찾고 그 부모의 마지막 자식인 p태그 참조 (o)


        c.  선택자:only-child 

          예> p:only-child {} <== p 태그의 부모를 찾고 그 부모의 유일한 자식인 p태그 참조 (o)

        d.  n 번째 자식, 배수 , 짝수, 홀수
	  
	    선택자:nth-child(n) < ==  n 번째 자식 참조,  1 부터 시작
	     
   
            선택자:nth-child(2n) < == n에 1 부터 값을 설정해서 2,4,6, 짝수번째
            선택자:nth-child(even)

	    선택자:nth-child(2n+1) < == 홀수번째
            선택자:nth-child(odd)


     다. 사용자 입력 태그에서 사용하는 의사 클래스

          a.   :focus  <== 포커스를 받았을 때

	   예> input:focus{ }    // blur 는 focus를 잃어버렸을 때

          b.  :checked <== checkbox 및 select 태그에서 값을 선택했을 때

            예> input:checked{ }   

          c.  :enabled  <== 활성화
	      :disabled <== 비활성화

	    예>input:enabled{ }
              input:disabled{ } 
 

  2) 의사 요소 ( pseudo elements )
   -  ::요소
   - 의사 클래스는 태그 전체(whole)가 스타일이 적용되고
     의사 요소는  부분(part)적으로 스타일이 적용됨.

    예> ::first-line
       ::before
       ::after

     가. ::first-line

       - 문단의 첫줄

       예>  p::first-line{}

           <p>
              AAA1 <br>
              AAA2 <br>
              AAA3 <br>
	   </p>

     나. ::first-letter

       - 텍스트의 첫글자

       예> p::first-letter{}

    
     다. 특정요소에 컨텐츠(문자열,image등) 삽입

         ::after{
             content: 값|url('이미지경로')
	 }

	 ::before{
             content: 값|url('이미지경로')
	 }


6. BOX 모델

    1) 개요
      CSS(html)에서 모든 요소(tag)는  box 로 관리한다.

    2) 구성요소

      가. 내용 ( content)
      나. 패딩 ( padding, 안쪽여백)
      다. 보더 ( border, 테두리 )
      라. 마진 ( margin, 바깥쪽 여백 )
        ==> body 태그에 기본적으로  margin: 8px 로 되어 있음.

     3) 블럭레벨 vs 인라인 레벨

     가. 블럭레벨
        - 기본적으로 웹 브라우저의 전체 너비(width)를 차지한다.
	  따라서 다음 요소는 새로운 라인(new line)에 추가가 된다. ( 가로 배치 )
	- 크롬 브라우저의 개발자도구(F12)에서 Box Model 그림을 보면 
	   명시적인 width와 height 값이 보인다.  예> 248 X 21
        - width 와 height 지정하면 적용이 된다.

     나. 인라인 레벨
        - 기본적으로 자신의 content 크기만큼만 너비(width)를 차지한다.
	  따라서 다음 요소는 같은 라인에 추가가 된다. ( 세로 배치 )
	- 크롬 브라우저의 개발자도구(F12)에서 Box Model 그림을 보면
	  width와 height 값이 auto 로 보인다.예 > auto X auto

	- width 와 height 지정하면 적용이 안된다. (**************)

     4) width 와 height 

       - Box 모델에서의 content(내용)의 너비와 높이를 의미한다.
         지정하지 않으면 블럭레벨인 경우에는 웹브라우저의 전체 너비(width)를 차지하고
	             인라인 레벨인 경우에는 자신의 content 크기만큼만 너비(width)를 차지한다.

       - 문법:
              width:절대값(px)|상대값(%,rem) <== 상대값은 부모, 
	                                     만약에 부모가 100px 이고 자식이 50% 라고 하면 자식너비는 50px 됨
	      height:절대값(px)|상대값(%,rem) <== 상대값은 부모 기준
	                                     만약에 부모가 100px 이고 자식이 50% 라고 하면 자식너비는 50px 됨

